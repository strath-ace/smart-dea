# This Source Code Form is subject to the terms of the Mozilla Public ---------------------
# License, v. 2.0. If a copy of the MPL was not distributed with this ---------------------
# file, You can obtain one at http://mozilla.org/MPL/2.0/. */ -----------------------------
# ---------------- Copyright (C) 2020 University of Strathclyde and Author ----------------
# -------------------------------- Author: Audrey Berquand --------------------------------
# ------------------------- e-mail: audrey.berquand@strath.ac.uk --------------------------
#
'''
Last modified: 15/04/2021
Author: A.Berquand, audrey.berquand@strath.ac.uk
Organisation: University of Strathclyde, ICE Lab

------------------------------------------------------------------------------------------------------------------------

Goal: Generate a TypeDB (formely known as Grakn) Schema written in TypeQL (formely known as graql) from a ECSS-E-TM-10-25A UML model (Annex A), parsed with XmiModelParser and stored in an `XModel`.
the XmiModelParser and other outputs generators were developed by Hans-Peter de Koning (ESA TEC-SYE) and are available on the OCDT GitHub. 
xmi2typeql is not a standalone script and requires as input the XMI model generated by the XmiModelParser.
'''

import os
import re
from types import NoneType as _NoneType
from datetime import datetime
import logging
LOGGER = logging.getLogger()

from xmi_verter_constants import OBJECT_ID_PROPERTY, OBJECT_TYPE_PROPERTY, OBJECT_REVISION_PROPERTY, OBJECT_CONTAINER_PROPERTY
from xmi_model import XModel, XClass, XProperty, XEnumerationType
from xmi_helpers import cap, convertCamelCaseToLowercaseWords
from xmi2typeql_data_v2_0_1 import DATA


class TypeQLGenerator(object):
    print "Creating TypeDB file"

    #   ------------------------------------------------------------------------------------------
    #   MAIN -------------------------------------------------------------------------------------
    #   ------------------------------------------------------------------------------------------  
    def generate(self, model, generatedCodePath):
        # input: xmi model
        # output: .tql file containing ECSS-E-TM-10-25A TypeDB schema layer

        assert isinstance(model, XModel)
        assert isinstance(generatedCodePath, str)
        assert os.path.isdir(generatedCodePath)

        # Create the TypeDB file with the model name, at the same location as the other generated files and open for writing
        TypeQLFileName = 'TypeDBSchema' + model.name + '_v2_0_1.tql'
        TypeQLFilePath = os.path.join(generatedCodePath, TypeQLFileName)
        TypeQLFile = open(TypeQLFilePath, 'w')
     
        # Define shortcut for writing to the class library source file
        w1 = TypeQLFile.write
                
        TypeQLFileBaseName = os.path.basename(TypeQLFilePath)
        LOGGER.info('Started generating TypeDB Schema Layer in file {}'.format(TypeQLFileBaseName))
        isoTimeStamp = datetime.now().replace(microsecond=0).isoformat(' ')

         # Generate the module header, namespace definition and using statements
        w1(DATA.ModuleHeader1.format(
            fileName=TypeQLFileName,
            timeStamp=isoTimeStamp,
            modelName=model.name,
            versionNumber=model.versionNumber))

        #   -----------------------------------------------
        #   From classes and properties to TypeDB entities
        #   -----------------------------------------------    
        # Get the list of classes sorted by class name
        sortedClassList = sorted(model.classes, key=lambda x: x.name)

        
        # The list allEntitiesInfo is used to store all info in each entity needed for the TypeDB schema
        allEntitiesInfo=[]
        # The list rolesDefinition is used to clarify the types of relationships (composite or not) and the roles of the related classes
        rolesDefinition = []

        # The method generateClassEntity is applied to all non-mixi classes, abstract or not.
        # This methods allows to identify the class inheritance, names and types of attributes owned or inherited from mixin classes, 
        # and relationships (containment and reference) where the entity is pointing to another entity
        for klass in sortedClassList:
            if klass.isMixin: continue # Skip Mixin classes 
            allEntitiesInfo,rolesDefinition = self.generateClassEntity(model, klass, allEntitiesInfo,rolesDefinition,w1)
          
        # The following loop allows to identify the relationships where the entity is being pointed at,
        # both for containment and reference
        for i in rolesDefinition:
            if i['roleType']=='Containment':
                for j in allEntitiesInfo:
                    if i['pointedClass'] == j['Name'] and i['nameParameter'] not in j['isContained']:
                        j['isContained'].append(i['nameParameter'])
                    
                    # if that class has a parent which is already pointed by this relationship, then add to inherited pointing
                    for parent in j['Inheritance']:
                        indexP=next((index for (index, d) in enumerate(allEntitiesInfo) if d["Name"] == parent), None)
                        if indexP and i['nameParameter'] in allEntitiesInfo[indexP]['isContained']:
                            j['inheritedIsContained'].append(i['nameParameter'])
                    # add relations when Thing (top class) is referred/contained
                    if j['Name'] != 'Thing':
                        indexThing=next((index for (index, d) in enumerate(allEntitiesInfo) if d["Name"] == 'Thing'), None)
                        if i['nameParameter'] in allEntitiesInfo[indexThing]['isContained']:
                            j['inheritedIsContained'].append(i['nameParameter'])


            elif i['roleType']=='Reference':
                for j in allEntitiesInfo:
                    if i['pointedClass'] == j['Name'] and i['nameParameter'] not in j['isReferred']:
                        j['isReferred'].append(i['nameParameter'])

                    # if that class has a parent which is already pointed by this relationship, then add to inherited pointing
                    for parent in j['Inheritance']:
                        indexP=next((index for (index, d) in enumerate(allEntitiesInfo) if d["Name"] == parent), None)
                        if indexP and i['nameParameter'] in allEntitiesInfo[indexP]['isReferred']:
                            j['inheritedIsReferred'].append(i['nameParameter'])

                    # add relations when Thing (top class) is referred/contained
                    if j['Name'] != 'Thing':
                        indexThing=next((index for (index, d) in enumerate(allEntitiesInfo) if d["Name"] == 'Thing'), None)
                        if i['nameParameter'] in allEntitiesInfo[indexThing]['isReferred']:
                            j['inheritedIsReferred'].append(i['nameParameter'])

            else: continue
        
        #   ------------------------------------------------------------------------------------------
        #   Write TypeDB file -------------------------------------------------------------------------
        #   ------------------------------------------------------------------------------------------ 
                    
        # Initiate Definition of TypeDB schema layer
        w1("define \n")

        # Migration of Classes into TypeDB  Entities
        w1("\n# Entity Definition \n")          
        self.writeClassEntity(allEntitiesInfo,w1)

        # Migration of values properties into TypeDB  attributes definition
        w1('\n# Attributes Definition \n ')
        self.writeAttributes(allEntitiesInfo,w1)

        # Migration of class properties into TypeDB  relationships
        w1('\n# Relationships Definition \n ')
        self.writeRelationships(rolesDefinition,w1)
        
        # Close generated TypeDB  file
        TypeQLFile.close()

        LOGGER.info('Finished generating TypeDB Schema Layer in file {}'.format(TypeQLFileBaseName))

        return 

    #   ------------------------------------------------------------------------------------------
    #   Class to typeDB Entities Methods ----------------------------------------------------------
    #   ------------------------------------------------------------------------------------------ 
    def generateClassEntity(self, model, klass, allEntitiesInfo, rolesDefinition,w1):
        # inputs: xmi model, list of Entities to be defined, list of roles of Entities
        # outputs: entity/class dictionary (inheritance, abstract or concrete, attributes, active roles) and active roles added to allEntitiesInfo and rolesDefinition

        assert isinstance(model, XModel)
        assert isinstance(klass, XClass)

        # dictionary of entity information to be migrated
        entityInfo = {'Name':'default', 'Inheritance':'default', 'IsAbstract':'default','Attribute':[], 'attType':[], 'contains':[],'isContained':[], 'inheritedIsContained':[], 'refers':[],'isReferred':[], 'inheritedIsReferred':[]}
 
        # Define Entity's name
        entityInfo['Name'] = klass.name

        # identify entity inheritance (superType)
        # mixing (interface) class cannot be parent entities, only one parent entity is allowed in TypeDB
        entityInheritance=[]
        entityMixinInheritance=[]
        grandparents=[]
        inheritedAttributes=[]
        for i in klass.superTypes:
            # if parent class is not a mixin
            if i.isMixin == False :
                entityInheritance.append(i.name)
                inheritedAttributes=i.properties + i.getMixinProperties()
                # get whole family tree: relevant to avoid redefining attributes inherited from Mixin by a grandparent
                for j in i.superTypes:
                    grandparents.append(j.name)
                    for h in j.superTypes:
                        grandparents.append(h.name)
                        for l in h.superTypes:
                            grandparents.append(l.name)
            else : 
                # if parent class is a mixin
                entityMixinInheritance.append(i.name)
                
        # Verify that there is only one parent class, TypeDB cannot handle more than one parent
        if len(entityInheritance) == 1:
                entityInfo['Inheritance'] = entityInheritance[0]       
        else:
                entityInfo['Inheritance'] = 'entity'
               
        # Check whether the class is abstract or not
        if klass.isAbstract: 
            entityInfo['IsAbstract'] = 'True'
            
        # Define the entity attributes 
        # getDirectProperties from xmi_model.py collects both owned attributes and inherited from mixin classes        
        attributes = klass.properties + klass.getMixinProperties()
        # get Redefined properties
        allRedefinedProperties = klass.getAllRedefinedProperties()

        
        # Other: 
        # # get inherited properties
        # allInheritedProperties=klass.getInheritedProperties(level=0)
        # # get Mixing Properties 
        # allMixinProperties=klass.getMixinProperties()
        
        for p in attributes :
            if p.isServerSideOnly or p in allRedefinedProperties:
               continue # Skip ServerSideOnly properties , skip properties are already in the top Thing class and skip properties that were redefined         

            if p.isRedefined:
               if p.redefinedProperty.xOwner.name in grandparents or p.redefinedProperty.xOwner.name in entityInheritance:
                   continue #Some properties appear as owned and redefined from parent by the parent already owns the attribute so it cannot be redefined

            # if attribute is of value type (i.e., not of class kind) and whether it is not an array (i.e, not an array: defined as [1..1] or [0..1]) 
            # therefore with an upperBound of 1, or is an array, it is to be migrated as a TypeDB attribute    
            if p.isClassType == False :
                # using the TypeQL type dictionary, identify property corresponding type (p.type.name) in TypeDB
                TypeQLType =  self.getTypeQLItemType(p)
                entityInfo['Attribute'].append(p.name)
                entityInfo['attType'].append(TypeQLType)

            # if attribute is of class type, it is to be migrated as a TypeQL relationship
            # if the class type is Composite then it is a containment class 
            if p.isClassType and p.isComposite :
                entityInfo['contains'].append(p.name)
                entityRole={'pointingClass': klass.name, 'pointedClass':p.type.name, 'roleType':'Containment', 'nameParameter':p.name}
                rolesDefinition.append(entityRole)
            
            # if the class type is Composite then it is a reference class 
            # N.B.: in TypeQL there is only one type of relationship therefore the difference between composite and non composite class is migrated via the 
            # TypeQL relationship convention naming (see method writeRelationships)
            if p.isClassType and p.isComposite == False :
                entityInfo['refers'].append(p.name)
                entityRole={'pointingClass': klass.name, 'pointedClass':p.type.name, 'roleType':'Reference', 'nameParameter':p.name}
                rolesDefinition.append(entityRole)

        allEntitiesInfo.append(entityInfo)

        return allEntitiesInfo, rolesDefinition 
        
    def writeClassEntity(self,allEntitiesInfo,w):
        # input: entity/class dictionary (inheritance, abstract or concrete, attributes, active + passive roles) 
        # output: TypeQL entity
          
        for i in allEntitiesInfo:  
            # Each line of the list allEntitiesInfo contains the dictionary of one entity,
            # and therefore all the info needed to define a TypeQL entity

            # String to hold the class definition statement
            entityDefinition = ''

            # Write class name
            entityDefinition += DATA.defineEntityName.format(name=i['Name'])

            # Write inheritance 
            entityDefinition += DATA.defineInheritance.format(nameSuperType=i['Inheritance'])

            # If abstract, Write  
            if i['IsAbstract'] == 'True':
                entityDefinition += DATA.abstract

            # Attribute attributes owned or inherited from mixin
            for j in i['Attribute']:
                # In TypeDB v2.0.1, iid is a keyword
                if j=='iid':
                    j='id'
                entityDefinition += DATA.addAttribute.format(attributeName = j)
            
            #Add Containment Roles
            if len(i['contains']) != 0: 
                for j in i['contains']:
                    entityDefinition += DATA.addRoleContains.format(roleName=j)
                        
            if len(i['isContained']) != 0: 
                for j in i['isContained']:
                   if j not in i['inheritedIsContained']:
                    entityDefinition += DATA.addRoleIsContained.format(roleName=j)

            #Add Reference Roles
            if len(i['refers']) != 0: 
                for j in i['refers']:
                    entityDefinition += DATA.addRoleRefers.format(roleName=j)

            if len(i['isReferred']) != 0:
                for j in i['isReferred']:
                     if j not in i['inheritedIsReferred']:
                        entityDefinition += DATA.addRoleIsReferred.format(roleName=j)
        
            entityDefinition = entityDefinition[:-1]
            entityDefinition += DATA.entityEnd

            # Write Entity Definition
            w(entityDefinition)

        return 
    
    #   ------------------------------------------------------------------------------------------
    #   From Properties to TypeDB Attributes or Relationships Methods  ----------------------------
    #   ------------------------------------------------------------------------------------------ 
    def writeAttributes(self,allEntitiesInfo,w):
        # input: entity/class dictionary (attributes and attributes types) 
        # outputs: definition of all attributes (including TypeQL datatype)
        listOfAttributes=[]

        for i in allEntitiesInfo:
            for j in i['Attribute']:
                attributeDefinition = ''

                if j not in listOfAttributes:
                    # In TypeDB v2.0.1, iid is a keyword
                    if j=='iid':
                        attributeDefinition+= DATA.defineAttribute.format(name= 'id', datatype= i['attType'][i['Attribute'].index(j)] )
                    else:
                        attributeDefinition+= DATA.defineAttribute.format(name= j, datatype= i['attType'][i['Attribute'].index(j)] )
                    listOfAttributes.append(j)
                    w(attributeDefinition)

        return

    def writeRelationships(self,rolesDefinition,w):

        # String to hold the class definition statement
        relContainment=[]
        relReference=[]

        for i in rolesDefinition:        
            relationshipDefinition = ''

            if i['roleType'] == 'Containment' and i['nameParameter'] not in relContainment:
                relationshipDefinition += DATA.createContainmentRelationship.format(parameterName = i['nameParameter'])
                relContainment.append(i['nameParameter'])
                w(relationshipDefinition)

            if i['roleType'] == 'Reference'and i['nameParameter'] not in relReference:
                relationshipDefinition+= DATA.createReferenceRelationship.format(parameterName = i['nameParameter'])
                relReference.append(i['nameParameter'])
                w(relationshipDefinition)
        return 
        # input: list of roles from the xmi-model
        # outputs: definition of all TypeQL relationships

    #   ------------------------------------------------------------------------------------------
    #   Data Types Equivalence Methods -----------------------------------------------------------
    #   ------------------------------------------------------------------------------------------ 
    def getTypeQLItemType(self,prop):
    # Return TypeDB type for property *prop*
        assert isinstance(prop, XProperty)
        TypeQLType = DATA.TypeQLTypeDict.get(prop.type.name, prop.type.name)
        return TypeQLType

